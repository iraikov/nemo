/* This file was generated by NEMO (http://wiki.call-cc.org/nemo) version 9.0
 on Thu Oct 23 15:24:41 2014 */

#include "nest.h"
#include "event.h"
#include "archiving_node.h"
#include "ring_buffer.h"
#include "connection.h"
#include "universal_data_logger.h"
#include "recordables_map.h"


#include <gsl/gsl_errno.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_sf_exp.h>
#include <gsl/gsl_odeiv2.h>
#define Ith(v,i)    (v[i])



#include <gsl/gsl_vector.h>
#include <gsl/gsl_multiroots.h>



namespace nest {



  extern "C" int Golgi_dynamics (double, const double*, double*, void*);


  extern "C" int Golgi_steadystate (const gsl_vector *, void *, gsl_vector *);


  class Golgi : public Archiving_Node { 

    public:

    ~Golgi ();
    Golgi (const Golgi &);
    Golgi ();

    using Node::connect_sender;
    using Node::handle;

    port check_connection(Connection&, port);
    
    void handle(SpikeEvent &);
    void handle(CurrentEvent &);
    void handle(DataLoggingRequest &); 
    
    port connect_sender(SpikeEvent &, port);
    port connect_sender(CurrentEvent &, port);
    port connect_sender(DataLoggingRequest &, port);
    
    void get_status(DictionaryDatum &) const;
    void set_status(const DictionaryDatum &);
    
    void init_node_(const Node& proto);
    void init_state_(const Node& proto);
    void init_buffers_();
    void calibrate();
    
    void update(Time const &, const long_t, const long_t);

    /**
     * Minimal spike receptor type.
     * @note Start with 1 so we can forbid port 0 to avoid accidental
     *       creation of connections with no receptor type set.
     */
    static const port MIN_SPIKE_RECEPTOR = 1;

    /** 
     * Spike receptors.
     */
    enum SpikeSynapseTypes { 

         AMPA_SPIKE_RECEPTOR=MIN_SPIKE_RECEPTOR,

      SUP_SPIKE_RECEPTOR

    };
  
    friend int Golgi_dynamics (double, const double*, double*, void*);

  
   friend  int Golgi_steadystate (const gsl_vector *, void *, gsl_vector *);

   int AMPA_transients (long_t lag);
  

   // The next two classes need to be friends to access the State_ class/member
   friend class RecordablesMap<Golgi>;
   friend class UniversalDataLogger<Golgi>;

  
   struct Parameters_ { 

    double KM_V0beta_n,Na_V0alpha_u,NaR_Shiftalpha_s,AMPA_e,NaR_Aalpha_f,CaLVA_k_m_inf,KA_Kalpha_b,KA_Kalpha_a,KCa_Kbeta_c,SK2_invo1,SK2_invo2,SK2_gbar,KV_Abeta_n,KM_Kalpha_n,KA_g,KA_e,Lkg_e,Lkg_g,HCN1_tEf,KA_Abeta_b,NaR_V0alpha_f,KA_Abeta_a,NaR_V0alpha_s,CaLVA_F,HCN1_tEs,KM_B_ninf,CaLVA_R,HCN1_tDs,CaLVA_g,NaP_V0alpha_m,SK2_diro1,CaHVA_Aalpha_s,CaHVA_Aalpha_u,SK2_diro2,HCN2_erev,HCN1_Ehalf,KA_V0_binf,KA_Kbeta_a,KA_Kbeta_b,Lkg_gbar,KM_gbar,AMPA_scale_factor,Na_gbar,CaLVA_v0_m_inf,NaP_gbar,ca_d,AMPA_tp,HCN2_tCs,CaLVA_k_h_inf,Na_erev,NaP_V0_minf,NaR_gbar,AMPA_tau1,AMPA_tau2,ca_F,KA_V0alpha_b,KA_V0alpha_a,KA_Aalpha_b,KA_Aalpha_a,KM_Kbeta_n,CaLVA_v0_tau_m1,CaLVA_v0_tau_m2,KA_gbar,KA_erev,HCN1_rB,HCN1_rA,KA_V0_ainf,AMPA_tauA,AMPA_tauB,CaLVA_v0_tau_h2,CaLVA_v0_tau_h1,NaR_Abeta_s,comp19_V_t,HCN2_Ehalf,CaLVA_v0_h_inf,NaR_Abeta_f,ca2_ca2o,Na_e,Na_g,NaR_Kalpha_f,SK2_dirc4,SK2_dirc3,SK2_dirc2,NaR_Kalpha_s,KV_Aalpha_n,KCa_Bbeta_c,NaR_e,NaR_g,KCa_Abeta_c,CaHVA_gbar,KCa_g,KCa_e,HCN2_rA,HCN2_rB,SK2_invc1,SK2_invc2,SK2_invc3,KCa_gbar,Lkg_erev,NaP_Kalpha_m,KA_K_ainf,ca_cai0,HCN1_erev,HCN1_gbar,KV_V0beta_n,KA_V0beta_b,KA_V0beta_a,NaP_g,NaP_e,NaP_B_minf,NaR_erev,KCa_Aalpha_c,ca2_ca2i0,NaR_V0beta_s,SK2_erev,comp21_L,KV_Kbeta_n,NaR_Aalpha_s,Na_Kbeta_u,Na_Kbeta_v,KCa_Kalpha_c,comp20_c,CaLVA_valence,NaP_Aalpha_m,HCN2_gbar,KM_erev,ca2_beta,CaLVA_C_tau_h,NaP_V0beta_m,KV_Kalpha_n,HCN2_c,HCN2_e,HCN2_g,NaP_Abeta_m,comp19_celsius,NaR_V0beta_f,CaHVA_Abeta_u,ca2_d,CaLVA_shift,SK2_g,HCN1_c,CaLVA_C_tau_m,CaLVA_A_tau_h,HCN1_e,SK2_e,HCN1_g,CaLVA_A_tau_m,KV_gbar,ca2_F,KM_Abeta_n,NaP_erev,KM_V0alpha_n,HCN2_tEs,CaHVA_V0alpha_s,NaP_Kbeta_m,CaHVA_Abeta_s,CaHVA_V0alpha_u,KM_V0_ninf,Na_Aalpha_u,Na_Aalpha_v,KA_K_binf,NaR_Kbeta_f,NaR_Kbeta_s,CaHVA_R,CaHVA_V0beta_u,CaHVA_V0beta_s,ca_beta,CaLVA_k_tau_h1,CaLVA_k_tau_h2,CaHVA_F,HCN2_tEf,CaHVA_Kalpha_s,CaHVA_Kalpha_u,CaLVA_k_tau_m2,KV_g,CaLVA_k_tau_m1,CaHVA_g,KV_e,KCa_Balpha_c,ca_cao,HCN1_tCf,NaR_Shiftbeta_s,CaLVA_gbar,KM_e,Na_V0beta_u,KM_g,Na_V0beta_v,KV_V0alpha_n,ca2_valence,HCN1_tCs,KV_erev,HCN2_tDs,Na_Kalpha_u,Na_Kalpha_v,HCN1_tDf,KM_Aalpha_n,HCN2_tCf,comp21_diam,Na_Abeta_v,Na_Abeta_u,KCa_erev,SK2_diff,CaHVA_Kbeta_u,CaHVA_Kbeta_s,Na_V0alpha_v,HCN2_tDf;    double celsius,V_t;
    Parameters_();
    void get(DictionaryDatum&) const;
    void set(const DictionaryDatum&);

  }; // end struct Parameters_


  struct State_ { 

      enum StateVecElems {
      AMPA_A = 27,
      AMPA_B = 26,
      CA2_CA2 = 25,
      CA_CA = 24,
      HCN2_O_SLOW = 23,
      HCN1_O_FAST = 22,
      HCN1_O_SLOW = 21,
      HCN2_O_FAST = 20,
      KM_M286 = 19,
      NAP_M302 = 18,
      KV_M291 = 17,
      NAR_H308 = 16,
      NAR_M307 = 15,
      CALVA_H270 = 14,
      CALVA_M269 = 13,
      NA_H297 = 12,
      KA_H276 = 11,
      KCA_M281 = 10,
      NA_M296 = 9,
      KA_M275 = 8,
      CAHVA_M263 = 7,
      SK2_SK2_ZC4 = 6,
      SK2_SK2_ZO2 = 5,
      SK2_SK2_ZC3 = 4,
      SK2_SK2_ZO1 = 3,
      SK2_SK2_ZC2 = 2,
      CAHVA_H264 = 1,
      V = 0
      };

      double y_[28]; 

      State_(const Parameters_& p); 
      State_(const State_& s);
      State_& operator=(const State_& s);
      void get(DictionaryDatum&) const;
      void set(const DictionaryDatum&, const Parameters_&);

     int_t r_; /* refractory counter */

  }; // end struct State_

  struct Variables_ { int_t RefractoryCounts_; double U_old_; /* for spike-detection */ };

  struct Buffers_ {

    Buffers_(Golgi&);
    Buffers_(const Buffers_&, Golgi&);
    UniversalDataLogger<Golgi> logger_;

    gsl_odeiv2_step*    s_;    //!< stepping function
    gsl_odeiv2_control* c_;    //!< adaptive stepsize control function
    gsl_odeiv2_evolve*  e_;    //!< evolution function
    gsl_odeiv2_system   sys_;  //!< struct describing system
    unsigned int N;  // size of state vector used by Jacobian
    double *u, *jac;  // intermediate state vectors used for Jacobian approximation


    RingBuffer spike_comp24;

    RingBuffer currents_;

    double_t step_;           //!< step size in ms
    double   IntegrationStep_;//!< current integration time step, updated by solver

  /** 
   * Input current injected by CurrentEvent.
   * This variable is used to transport the current applied into the
   * _dynamics function computing the derivative of the state vector.
   * It must be a part of Buffers_, since it is initialized once before
   * the first simulation, but not modified before later Simulate calls.
   */
    double_t I_stim_;

    }; // end struct Buffers_

  template <State_::StateVecElems elem>
  double_t get_y_elem_() const { return S_.y_[elem]; }

  Parameters_ P_;
  State_      S_;
  Variables_  V_;
  Buffers_    B_;

  static RecordablesMap<Golgi> recordablesMap_;

  }; // end class Golgi

  inline port Golgi::check_connection(Connection& c, port receptor_type)
  {
    SpikeEvent e;
    e.set_sender(*this);
    c.check_event(e);
    return c.get_target()->connect_sender(e, receptor_type);
  }


  inline port Golgi::connect_sender(SpikeEvent&, port receptor_type)
  {
    if ( receptor_type < MIN_SPIKE_RECEPTOR || receptor_type >= SUP_SPIKE_RECEPTOR )
    {
      if ( receptor_type < 0 || receptor_type >= SUP_SPIKE_RECEPTOR )
	throw UnknownReceptorType(receptor_type, get_name());
      else
	throw IncompatibleReceptorType(receptor_type, get_name(), "SpikeEvent");
    }
    return receptor_type;
  }
 
  inline port Golgi::connect_sender(CurrentEvent&, port receptor_type)
  {
    if (receptor_type != 0)
      throw UnknownReceptorType(receptor_type, get_name());
    return 0;
  }

  inline port Golgi::connect_sender(DataLoggingRequest& dlr, 
				            port receptor_type)
  {
    if (receptor_type != 0)
      throw UnknownReceptorType(receptor_type, get_name());
    return B_.logger_.connect_logging_device(dlr, recordablesMap_);
  }

  inline void Golgi::get_status(DictionaryDatum &d) const
  {
    P_.get(d);
    S_.get(d);
    Archiving_Node::get_status(d);

    (*d)[names::recordables] = recordablesMap_.get_list();

    def<double_t>(d, names::t_spike, get_spiketime_ms());

    DictionaryDatum receptor_dict_ = new Dictionary();

   (*receptor_dict_)[Name("AMPA")]  = AMPA_SPIKE_RECEPTOR;

               
    (*d)[names::receptor_types] = receptor_dict_;
  }


  inline void Golgi::set_status(const DictionaryDatum &d)
  {
    Parameters_ ptmp = P_;  // temporary copy in case of errors
    ptmp.set(d);                       // throws if BadProperty
    State_      stmp = S_;  // temporary copy in case of errors
    stmp.set(d, ptmp);                 // throws if BadProperty

    // We now know that (ptmp, stmp) are consistent. We do not 
    // write them back to (P_, S_) before we are also sure that 
    // the properties to be set in the parent class are internally 
    // consistent.
    Archiving_Node::set_status(d);

    // if we get here, temporaries contain consistent set of properties
    P_ = ptmp;
    S_ = stmp;

    calibrate();
  }

} // end namespace nest



