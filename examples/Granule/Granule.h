/* This file was generated by NEMO (http://wiki.call-cc.org/nemo) version 9.0
 on Mon Oct  6 11:27:15 2014 */

#include "nest.h"
#include "event.h"
#include "archiving_node.h"
#include "ring_buffer.h"
#include "connection.h"
#include "universal_data_logger.h"
#include "recordables_map.h"


#include <sundials/sundials_types.h> /* definition of type realtype */
#include <nvector/nvector_serial.h>  /* serial N_Vector types, fcts., macros */
#include <ida/ida.h>                 /* prototypes for IDA fcts., consts. */
#include <ida/ida_dense.h>")
#define Ith(v,i)    NV_Ith_S(v,i)    /* Ith component in a vector */



#include <gsl/gsl_vector.h>
#include <gsl/gsl_multiroots.h>



namespace nest {


  /**
   * Exception to be thrown if an IDA solver does not return IDA_SUCCESS
   * @ingroup KernelExceptions
   */
  class IDASolverFailure: public KernelException
  {
  public:
    /**
    * @note model should be passed from get_name() to ensure that
    *             names of copied models are reported correctly. 
    * @param model name of model causing problem
    * @param status exit status of the IDA solver
    */
    IDASolverFailure(const std::string& model,
                     const int status)
      : KernelException("IDASolverFailure"),
        model_(model),
        status_(status)
      {}
    ~IDASolverFailure() throw() {}
    
    std::string message()
    {
      std::ostringstream msg;
      msg << "In model " << model_ << ", the IDA solver "
          << "returned with exit status " << status_ << ".\n";
      return msg.str();
    }

    private:
      const std::string model_;
      const int status_;
  };


  extern "C" int Granule_dynamics (double, const double*, double*, void*);


  extern "C" int Granule_steadystate (const gsl_vector *, void *, gsl_vector *);


  class Granule public Archiving_Node { 

    ~Granule ();
    Granule (const Granule &);
    Granule ();

    using Node::connect_sender;
    using Node::handle;

    port check_connection(Connection&, port);
    
    void handle(SpikeEvent &);
    void handle(CurrentEvent &);
    void handle(DataLoggingRequest &); 
    
    port connect_sender(SpikeEvent &, port);
    port connect_sender(CurrentEvent &, port);
    port connect_sender(DataLoggingRequest &, port);
    
    void get_status(DictionaryDatum &) const;
    void set_status(const DictionaryDatum &);
    
    void init_node_(const Node& proto);
    void init_state_(const Node& proto);
    void init_buffers_();
    void calibrate();
    
    void update(Time const &, const long_t, const long_t);

    /**
     * Minimal spike receptor type.
     * @note Start with 1 so we can forbid port 0 to avoid accidental
     *       creation of connections with no receptor type set.
     */
    static const port MIN_SPIKE_RECEPTOR = 1;

    /** 
     * Spike receptors.
     */
    enum SpikeSynapseTypes { 

         GABA_SPIKE_RECEPTOR=MIN_SPIKE_RECEPTOR,

         NMDA_SPIKE_RECEPTOR,

         AMPA_SPIKE_RECEPTOR,

      SUP_SPIKE_RECEPTOR

    };
  
    friend int Granule_residual (double, N_Vector, N_Vector, N_Vector, void*);
    friend int Granule_event (double, N_Vector, N_Vector, double *, void*);

  
   friend  int Granule_steadystate (const gsl_vector *, void *, gsl_vector *);

   int GABA_transients (long_t lag);
   int NMDA_transients (long_t lag);
   int AMPA_transients (long_t lag);
  

   // The next two classes need to be friends to access the State_ class/member
   friend class RecordablesMap<Granule>;
   friend class UniversalDataLogger<Granule>;

  
   struct Parameters_ { 

    double comp162_Vteta,comp121_Kalpha_n,comp135_vcbdur,comp136_V0beta_n,comp50_vchold,comp162_Agamma,comp135_vchold,comp121_V0beta_n,comp156_e,comp20_C_m,comp52_V0beta_b,comp52_V0beta_a,comp159_ggaba,comp162_ACon,comp87_vchdur,comp88_Aalpha_c,comp178_vcbase,comp135_vcinc,comp88_Abeta_c,comp136_Kbeta_n,comp22_tauA,comp50_vcbase,comp87_vchold,comp22_tauB,comp21_L,comp22_tau1,comp136_Kalpha_n,comp22_tau2,comp52_K_binf,comp87_vcsteps,comp26_V0beta_u,comp26_V0beta_s,comp121_Aalpha_n,comp120_vcbase,comp25_cao,comp52_Aalpha_b,comp105_cnbase,comp52_Aalpha_a,comp106_Kalpha_d,comp25_d,comp155_vcinc,comp25_F,comp23_scale_factor,comp136_Aalpha_n,comp162_e,comp178_vcsteps,comp26_R,comp26_Aalpha_u,comp26_Aalpha_s,comp105_cnout,comp21_diam,comp135_vchdur,comp26_F,comp50_cnout,comp178_vcbdur,comp26_Kalpha_s,comp26_Kalpha_u,comp26_Kbeta_s,comp19_Ra,comp26_Kbeta_u,comp159_egaba,comp106_e,comp52_Kbeta_b,comp52_Kbeta_a,comp162_AOoff,comp162_AOon,comp136_Abeta_n,comp52_V0alpha_b,comp136_e,comp52_V0alpha_a,comp105_vcsteps,comp178_vchdur,comp50_cn,comp26_V0alpha_u,comp162_Abeta,comp26_V0alpha_s,comp120_vchold,comp105_cnsteps,comp162_Vbeta,comp88_Balpha_c,comp24_scale_factor,comp52_K_ainf,comp105_vcinc,comp52_Abeta_b,comp52_Abeta_a,comp87_vcbdur,comp87_vcinc,comp136_V0alpha_n,comp178_vchold,comp105_cninc,comp162_n2,comp162_n1,comp162_n4,comp121_Abeta_n,comp162_n3,comp26_Abeta_u,comp26_Abeta_s,comp52_e,comp52_V0_ainf,comp155_vcsteps,comp162_Aalfa,comp178_vcinc,comp88_Kbeta_c,comp155_vchdur,comp105_cnhold,comp121_e,comp88_Kalpha_c,comp19_V_t,comp120_vcbdur,comp24_e,comp22_e,comp106_V0alpha_d,comp121_B_ninf,comp22_scale_factor,comp50_vchdur,comp106_gbar,comp25_beta,comp19_celsius,comp162_gbar,comp105_vcbdur,comp106_V0beta_d,comp50_vcsteps,comp106_Abeta_d,comp24_tp,comp120_vcinc,comp162_Ateta,comp155_vcbase,comp50_vcbdur,comp88_e,comp26_gbar,comp121_gbar,comp25_cai0,comp106_Aalpha_d,comp155_vcbdur,comp23_e,comp50_vcinc,comp121_V0alpha_n,comp88_Bbeta_c,comp155_vchold,comp52_Kalpha_b,comp52_Kalpha_a,comp162_ACoff,comp52_gbar,comp156_gbar,comp87_vcbase,comp120_vchdur,comp22_tp,comp162_Aepsilon,comp23_tauB,comp23_tauA,comp23_tau2,comp23_tau1,comp121_V0_ninf,comp162_Adelta,comp105_vchold,comp105_vchdur,comp24_tau1,comp105_vcbase,comp120_vcsteps,comp121_Kbeta_n,comp24_tau2,comp24_tauA,comp136_gbar,comp106_Kbeta_d,comp24_tauB,comp162_Valfa,comp23_tp,comp52_V0_binf,comp88_gbar,comp135_vcbase,comp135_vcsteps;    double celsius,V_t;
    Parameters_();
    void get(DictionaryDatum&) const;
    void set(const DictionaryDatum&);

  }; // end struct Parameters_


  struct State_ { 

      enum StateVecElems {
      COMP23_A = 27,
      COMP23_B = 26,
      COMP22_A = 25,
      COMP22_B = 24,
      COMP24_A = 23,
      COMP24_B = 22,
      COMP25_CA = 21,
      KM_M205 = 20,
      KCA_M195 = 19,
      KA_M189 = 18,
      COMP162_NA_ZO = 17,
      COMP162_NA_ZI6 = 16,
      COMP162_NA_ZC5 = 15,
      COMP162_NA_ZI5 = 14,
      COMP162_NA_ZC4 = 13,
      COMP162_NA_ZI4 = 12,
      COMP162_NA_ZC3 = 11,
      COMP162_NA_ZI3 = 10,
      COMP162_NA_ZC2 = 9,
      COMP162_NA_ZI2 = 8,
      COMP162_NA_ZC1 = 7,
      COMP162_NA_ZI1 = 6,
      CAHVA_H184 = 5,
      CAHVA_M183 = 4,
      KV_M210 = 3,
      KA_H190 = 2,
      KIR_M200 = 1,
      V = 0
      }

      double y_[28]; 

      State_(const Parameters_& p); 
      State_(const State_& s);
      State_& operator=(const State_& s);
      void get(DictionaryDatum&) const;
      void set(const DictionaryDatum&, const Parameters_&);


  }; // end struct State_

  struct Variables_ {};

  struct Buffers_ {

    Buffers_(Granule&);
    Buffers_(const Buffers_&, Granule&);
    UniversalDataLogger<Granule> logger_;

    N_Vector y, y1;    //!< current state vector used by IDA
    N_Vector yp;    //!< derivatives vector used by IDA
    void *   sys_;  //!< IDA control structure


    RingBuffer spike_comp23;
    RingBuffer spike_comp24;
    RingBuffer spike_comp22;

    RingBuffer currents_;

    double_t step_;           //!< step size in ms
    double   IntegrationStep_;//!< current integration time step, updated by solver

  /** 
   * Input current injected by CurrentEvent.
   * This variable is used to transport the current applied into the
   * _dynamics function computing the derivative of the state vector.
   * It must be a part of Buffers_, since it is initialized once before
   * the first simulation, but not modified before later Simulate calls.
   */
    double_t I_stim_;

    }; // end struct Buffers_

  template <State_::StateVecElems elem>
  double_t get_y_elem_() const { return S_.y_[elem]; }

  Parameters_ P_;
  State_      S_;
  Variables_  V_;
  Buffers_    B_;

  static RecordablesMap<Granule> recordablesMap_;

  }; // end class Granule
  inline port Granule::check_connection(Connection& c, port receptor_type)
  {
    SpikeEvent e;
    e.set_sender(*this);
    c.check_event(e);
    return c.get_target()->connect_sender(e, receptor_type);
  }


  inline port Granule::connect_sender(SpikeEvent&, port receptor_type)
  {
    if ( receptor_type < MIN_SPIKE_RECEPTOR || receptor_type >= SUP_SPIKE_RECEPTOR )
    {
      if ( receptor_type < 0 || receptor_type >= SUP_SPIKE_RECEPTOR )
	throw UnknownReceptorType(receptor_type, get_name());
      else
	throw IncompatibleReceptorType(receptor_type, get_name(), "SpikeEvent");
    }
    return receptor_type;
  }
 
  inline port Granule::connect_sender(CurrentEvent&, port receptor_type)
  {
    if (receptor_type != 0)
      throw UnknownReceptorType(receptor_type, get_name());
    return 0;
  }

  inline port Granule::connect_sender(DataLoggingRequest& dlr, 
				            port receptor_type)
  {
    if (receptor_type != 0)
      throw UnknownReceptorType(receptor_type, get_name());
    return B_.logger_.connect_logging_device(dlr, recordablesMap_);
  }

  inline void Granule::get_status(DictionaryDatum &d) const
  {
    P_.get(d);
    S_.get(d);
    Archiving_Node::get_status(d);

    (*d)[names::recordables] = recordablesMap_.get_list();

    def<double_t>(d, names::t_spike, get_spiketime_ms());

    DictionaryDatum receptor_dict_ = new Dictionary();

   (*receptor_dict_)[Name(\"GABA\")]  = GABA_SPIKE_RECEPTOR;

   (*receptor_dict_)[Name(\"NMDA\")]  = NMDA_SPIKE_RECEPTOR;

   (*receptor_dict_)[Name(\"AMPA\")]  = AMPA_SPIKE_RECEPTOR;

               
    (*d)[names::receptor_types] = receptor_dict_;
  }


  inline void Granule::set_status(const DictionaryDatum &d)
  {
    Parameters_ ptmp = P_;  // temporary copy in case of errors
    ptmp.set(d);                       // throws if BadProperty
    State_      stmp = S_;  // temporary copy in case of errors
    stmp.set(d, ptmp);                 // throws if BadProperty

    // We now know that (ptmp, stmp) are consistent. We do not 
    // write them back to (P_, S_) before we are also sure that 
    // the properties to be set in the parent class are internally 
    // consistent.
    Archiving_Node::set_status(d);

    // if we get here, temporaries contain consistent set of properties
    P_ = ptmp;
    S_ = stmp;

    calibrate();
  }

} // end namespace nest



