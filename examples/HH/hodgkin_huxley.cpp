


/* This file was generated by NEMO (http://wiki.call-cc.org/nemo) version 9.0 on Thu Oct 23 23:30:27 2014 */


#include "hodgkin_huxley.h"
#include "exceptions.h"
#include "network.h"
#include "dict.h"
#include "integerdatum.h"
#include "doubledatum.h"
#include "dictutils.h"
#include "numerics.h"
#include <limits>

#include "universal_data_logger_impl.h"

#include <iomanip>
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
namespace nest {




  int fsolve (int (*fss)(const gsl_vector *, void *user_data, gsl_vector *), int N, gsl_vector *fval, void *user_data, std::string name)
  {
      
      const gsl_multiroot_fsolver_type * T = gsl_multiroot_fsolver_hybrid;
      gsl_multiroot_fsolver * s = gsl_multiroot_fsolver_alloc (T, N);
      gsl_multiroot_function f = {fss, N, user_data};

      int status, iter;
      gsl_vector *x = gsl_vector_alloc (N);
      
      for (int i = 0; i < N; i++)
      {
         gsl_vector_set (x, i, 0.0);
      }

      gsl_multiroot_fsolver_set (s, &f, x);

      iter = 0;
      do
      {
         iter++;
         status = gsl_multiroot_fsolver_iterate (s);

         if ((status == GSL_EBADFUNC) ||
             (status == GSL_ENOPROG))
         {
            throw GSLSolverFailure(name, status);
         }
         
         status =  gsl_multiroot_test_residual (s->f, 1e-7);
      }
      while (status == GSL_CONTINUE && iter < 1000);

      for (int i = 0; i < N; i++)
      {
         gsl_vector_set (fval, i, gsl_vector_get (s->x, i));
      }

      gsl_vector_free (x);
      gsl_multiroot_fsolver_free (s);

      return 0;
  }




double K_bnf (double v, const void* params);



double Na_amf (double v, const void* params);



double K_anf (double v, const void* params);



double Na_bhf (double v, const void* params);



double Na_ahf (double v, const void* params);



double Na_bmf (double v, const void* params);




double K_bnf (double v, const void* params) {

  double rv74;

  double K_C_beta_n, K_B_beta_n, K_A_beta_n;
  const ::Parameters_ & p = *(reinterpret_cast< const ::Parameters_ *>(params));

  K_C_beta_n =  p.K_C_beta_n;
  K_B_beta_n =  p.K_B_beta_n;
  K_A_beta_n =  p.K_A_beta_n;
  rv74  =  K_A_beta_n * exp(-(v + -(K_B_beta_n)) / K_C_beta_n);
  return rv74;
}



double Na_amf (double v, const void* params) {

  double rv75;

  double Na_C_alpha_m, Na_B_alpha_m, Na_A_alpha_m;
  const ::Parameters_ & p = *(reinterpret_cast< const ::Parameters_ *>(params));

  Na_C_alpha_m =  p.Na_C_alpha_m;
  Na_B_alpha_m =  p.Na_B_alpha_m;
  Na_A_alpha_m =  p.Na_A_alpha_m;
  rv75  =  Na_A_alpha_m * (v + -(Na_B_alpha_m)) / (1.0 + -(exp(-(v + -(Na_B_alpha_m)) / Na_C_alpha_m)));
  return rv75;
}



double K_anf (double v, const void* params) {

  double rv76;

  double K_C_alpha_n, K_B_alpha_n, K_A_alpha_n;
  const ::Parameters_ & p = *(reinterpret_cast< const ::Parameters_ *>(params));

  K_C_alpha_n =  p.K_C_alpha_n;
  K_B_alpha_n =  p.K_B_alpha_n;
  K_A_alpha_n =  p.K_A_alpha_n;
  rv76  =  K_A_alpha_n * (v + -(K_B_alpha_n)) / (1.0 + -(exp(-(v + -(K_B_alpha_n)) / K_C_alpha_n)));
  return rv76;
}



double Na_bhf (double v, const void* params) {

  double rv77;

  double Na_C_beta_h, Na_B_beta_h, Na_A_beta_h;
  const ::Parameters_ & p = *(reinterpret_cast< const ::Parameters_ *>(params));

  Na_C_beta_h =  p.Na_C_beta_h;
  Na_B_beta_h =  p.Na_B_beta_h;
  Na_A_beta_h =  p.Na_A_beta_h;
  rv77  =  Na_A_beta_h / (1.0 + exp(-(v + -(Na_B_beta_h)) / Na_C_beta_h));
  return rv77;
}



double Na_ahf (double v, const void* params) {

  double rv78;

  double Na_C_alpha_h, Na_B_alpha_h, Na_A_alpha_h;
  const ::Parameters_ & p = *(reinterpret_cast< const ::Parameters_ *>(params));

  Na_C_alpha_h =  p.Na_C_alpha_h;
  Na_B_alpha_h =  p.Na_B_alpha_h;
  Na_A_alpha_h =  p.Na_A_alpha_h;
  rv78  =  Na_A_alpha_h * exp(-(v + -(Na_B_alpha_h)) / Na_C_alpha_h);
  return rv78;
}



double Na_bmf (double v, const void* params) {

  double rv79;

  double Na_C_beta_m, Na_B_beta_m, Na_A_beta_m;
  const ::Parameters_ & p = *(reinterpret_cast< const ::Parameters_ *>(params));

  Na_C_beta_m =  p.Na_C_beta_m;
  Na_B_beta_m =  p.Na_B_beta_m;
  Na_A_beta_m =  p.Na_A_beta_m;
  rv79  =  Na_A_beta_m * exp(-(v + -(Na_B_beta_m)) / Na_C_beta_m);
  return rv79;
}




extern "C" int hodgkin_huxley_dynamics (double t, const double y[], double f[], void* pnode)
{

   double v68, v70, v72, Na_m60O, Na_m60, K_m66O, K_m66, Na_h61O, Na_h61, K_erev, v, K_gbar, i_K, ik, Na_erev, Na_gbar, i_Na, ina, Leak_erev, Leak_gbar, i_Leak, i, Na_C_alpha_h, Na_C_alpha_m, Na_A_alpha_h, Na_A_alpha_m, K_B_alpha_n, K_e, comp19_V_t, K_g, K_A_alpha_n, comp20_C, Na_C_beta_h, K_C_beta_n, Na_C_beta_m, Na_A_beta_m, comp19_Vrest, K_B_beta_n, Na_B_alpha_m, Na_A_beta_h, Na_e, Na_B_alpha_h, Na_g, Na_B_beta_m, K_C_alpha_n, Leak_g, K_A_beta_n, Leak_e, Na_B_beta_h;

   // S is shorthand for the type that describes the model state
   typedef hodgkin_huxley::State_ S;
	
   // cast the node ptr to an object of the proper type
   assert(pnode);
   const hodgkin_huxley & node =  *(reinterpret_cast<hodgkin_huxley*>(pnode));
   hodgkin_huxley & vnode =  *(reinterpret_cast<hodgkin_huxley*>(pnode));

   // params is a reference to the model parameters
   const struct hodgkin_huxley::Parameters_ *params;
   params = &(node.P_);

   // state is a reference to the model state
   struct hodgkin_huxley::State_ *state;
   state = &(vnode.S_);
	
   // y[] must be the state vector supplied by the integrator,
   // not the state vector in the node, node.S_.y[].

   K_erev  =  params->K_erev;

   Na_C_alpha_h  =  params->Na_C_alpha_h;

   Na_C_alpha_m  =  params->Na_C_alpha_m;

   Na_A_alpha_h  =  params->Na_A_alpha_h;

   Na_gbar  =  params->Na_gbar;

   Na_A_alpha_m  =  params->Na_A_alpha_m;

   K_gbar  =  params->K_gbar;

   K_B_alpha_n  =  params->K_B_alpha_n;

   K_e  =  params->K_e;

   Leak_erev  =  params->Leak_erev;

   comp19_V_t  =  params->comp19_V_t;

   K_g  =  params->K_g;

   K_A_alpha_n  =  params->K_A_alpha_n;

   Na_erev  =  params->Na_erev;

   comp20_C  =  params->comp20_C;

   Na_C_beta_h  =  params->Na_C_beta_h;

   K_C_beta_n  =  params->K_C_beta_n;

   Na_C_beta_m  =  params->Na_C_beta_m;

   Na_A_beta_m  =  params->Na_A_beta_m;

   comp19_Vrest  =  params->comp19_Vrest;

   K_B_beta_n  =  params->K_B_beta_n;

   Leak_gbar  =  params->Leak_gbar;

   Na_B_alpha_m  =  params->Na_B_alpha_m;

   Na_A_beta_h  =  params->Na_A_beta_h;

   Na_e  =  params->Na_e;

   Na_B_alpha_h  =  params->Na_B_alpha_h;

   Na_g  =  params->Na_g;

   Na_B_beta_m  =  params->Na_B_beta_m;

   K_C_alpha_n  =  params->K_C_alpha_n;

   Leak_g  =  params->Leak_g;

   K_A_beta_n  =  params->K_A_beta_n;

   Leak_e  =  params->Leak_e;

   Na_B_beta_h  =  params->Na_B_beta_h;


   v  =  Ith(y,0);

   Na_h61O  =  Ith(y,1);

   K_m66O  =  Ith(y,2);

   Na_m60O  =  Ith(y,3);


   Na_m60  =  Na_m60O;

   K_m66  =  K_m66O;

   Na_h61  =  Na_h61O;

   i_K  =  (K_gbar * pow(K_m66, 4.0)) * (v - K_erev);

   ik  =  i_K;

   i_Na  =  (Na_gbar * pow(Na_m60, 3.0) * Na_h61) * (v - Na_erev);

   ina  =  i_Na;

   i_Leak  =  Leak_gbar * (v - Leak_erev);

   i  =  i_Leak;


   Ith(f,0)  =  ((node.B_.I_stim_) + -0.001 * (ina + ik + i)) / comp20_C;

   v68  =  Na_h61O;; 
Ith(f,1)  =  -(Na_h61O * Na_bhf(v, params)) + (1.0 - v68) * (Na_ahf(v, params));

   v70  =  K_m66O;; 
Ith(f,2)  =  -(K_m66O * K_bnf(v, params)) + (1.0 - v70) * (K_anf(v, params));

   v72  =  Na_m60O;; 
Ith(f,3)  =  -(Na_m60O * Na_bmf(v, params)) + (1.0 - v72) * (Na_amf(v, params));


   return GSL_SUCCESS;

}



extern "C" int hodgkin_huxley_steadystate (const gsl_vector *u, void *pnode, gsl_vector *f)
{
   double v, comp19_Vrest, Na_h61, Na_h61O, K_m66, K_m66O, Na_m60, Na_m60O, i_K, ik, i_Na, ina, i_Leak, i, K_erev, Na_C_alpha_h, Na_C_alpha_m, Na_A_alpha_h, Na_gbar, Na_A_alpha_m, K_gbar, K_B_alpha_n, K_e, Leak_erev, comp19_V_t, K_g, K_A_alpha_n, Na_erev, comp20_C, Na_C_beta_h, K_C_beta_n, Na_C_beta_m, Na_A_beta_m, K_B_beta_n, Leak_gbar, Na_B_alpha_m, Na_A_beta_h, Na_e, Na_B_alpha_h, Na_g, Na_B_beta_m, K_C_alpha_n, Leak_g, K_A_beta_n, Leak_e, Na_B_beta_h;

   // params is a reference to the model parameters
   const struct hodgkin_huxley::Parameters_ *params = (struct hodgkin_huxley::Parameters_ *)pnode;

   K_erev  =  params->K_erev;

   Na_C_alpha_h  =  params->Na_C_alpha_h;

   Na_C_alpha_m  =  params->Na_C_alpha_m;

   Na_A_alpha_h  =  params->Na_A_alpha_h;

   Na_gbar  =  params->Na_gbar;

   Na_A_alpha_m  =  params->Na_A_alpha_m;

   K_gbar  =  params->K_gbar;

   K_B_alpha_n  =  params->K_B_alpha_n;

   K_e  =  params->K_e;

   Leak_erev  =  params->Leak_erev;

   comp19_V_t  =  params->comp19_V_t;

   K_g  =  params->K_g;

   K_A_alpha_n  =  params->K_A_alpha_n;

   Na_erev  =  params->Na_erev;

   comp20_C  =  params->comp20_C;

   Na_C_beta_h  =  params->Na_C_beta_h;

   K_C_beta_n  =  params->K_C_beta_n;

   Na_C_beta_m  =  params->Na_C_beta_m;

   Na_A_beta_m  =  params->Na_A_beta_m;

   comp19_Vrest  =  params->comp19_Vrest;

   K_B_beta_n  =  params->K_B_beta_n;

   Leak_gbar  =  params->Leak_gbar;

   Na_B_alpha_m  =  params->Na_B_alpha_m;

   Na_A_beta_h  =  params->Na_A_beta_h;

   Na_e  =  params->Na_e;

   Na_B_alpha_h  =  params->Na_B_alpha_h;

   Na_g  =  params->Na_g;

   Na_B_beta_m  =  params->Na_B_beta_m;

   K_C_alpha_n  =  params->K_C_alpha_n;

   Leak_g  =  params->Leak_g;

   K_A_beta_n  =  params->K_A_beta_n;

   Leak_e  =  params->Leak_e;

   Na_B_beta_h  =  params->Na_B_beta_h;




   i_K  =  0.0;

   ik  =  0.0;

   i_Na  =  0.0;

   ina  =  0.0;

   i_Leak  =  0.0;

   i  =  0.0;


   v  =  -65.0;

   Na_h61  =  (Na_ahf(comp19_Vrest, params)) / (Na_ahf(comp19_Vrest, params) + Na_bhf(comp19_Vrest, params));

   Na_h61O  =  Na_h61;

   K_m66  =  (K_anf(comp19_Vrest, params)) / (K_anf(comp19_Vrest, params) + K_bnf(comp19_Vrest, params));

   K_m66O  =  K_m66;

   Na_m60  =  (Na_amf(comp19_Vrest, params)) / (Na_amf(comp19_Vrest, params) + Na_bmf(comp19_Vrest, params));

   Na_m60O  =  Na_m60;



   return 0;
}

// Diagonal Jacobian approximation: (f(s+.01) - f(s))/.001 

// GSL:
// int (* jacobian) (double t, const double y[], double * dfdy, double dfdt[], void * params);


extern "C" int hodgkin_huxley_jacobian (double t, const double y[], double *dfdy, double dfdt[], void* pnode)
{
   // cast the node ptr to an object of the proper type
   assert(pnode);
   const hodgkin_huxley & node = *(reinterpret_cast<hodgkin_huxley*>(pnode));
   hodgkin_huxley & vnode =  *(reinterpret_cast<hodgkin_huxley*>(pnode));

   // state is a reference to the model state
   struct hodgkin_huxley::Buffers_ *b;
   b = &(vnode.B_);

   for (int i = 0; i < b->N; i++) 
   {
       b->u[i] = y[i] + 0.01;
   }

   hodgkin_huxley_dynamics(t, b->u, b->jac, pnode);
   for (int i = 0; i < b->N; i++) 
   {
       dfdt[i*b->N + i] = (b->jac[i] - dfdy[i]) / .001;
   }
   return 0;

}



hodgkin_huxley::Parameters_::Parameters_ ():
      

  K_erev  (-77.0),

  Na_C_alpha_h  (20.0),

  Na_C_alpha_m  (10.0),

  Na_A_alpha_h  (0.07),

  Na_gbar  (0.12),

  Na_A_alpha_m  (0.1),

  K_gbar  (0.036),

  K_B_alpha_n  (-55.0),

  K_e  (-77.0),

  Leak_erev  (-54.4),

  comp19_V_t  (-35.0),

  K_g  (0.036),

  K_A_alpha_n  (0.01),

  Na_erev  (50.0),

  comp20_C  (1.0),

  Na_C_beta_h  (10.0),

  K_C_beta_n  (80.0),

  Na_C_beta_m  (18.0),

  Na_A_beta_m  (4.0),

  comp19_Vrest  (-65.0),

  K_B_beta_n  (-65.0),

  Leak_gbar  (0.0003),

  Na_B_alpha_m  (-40.0),

  Na_A_beta_h  (1.0),

  Na_e  (50.0),

  Na_B_alpha_h  (-65.0),

  Na_g  (0.12),

  Na_B_beta_m  (-65.0),

  K_C_alpha_n  (10.0),

  Leak_g  (0.0003),

  K_A_beta_n  (0.125),

  Leak_e  (-54.4),

  Na_B_beta_h  (-35.0)

  {
  Vrest  =  comp19_Vrest;

  V_t  =  comp19_V_t;

  }
hodgkin_huxley::State_::State_ (const Parameters_& p)
{

   double v, comp19_Vrest, Na_h61, Na_h61O, K_m66, K_m66O, Na_m60, Na_m60O, i_K, ik, i_Na, ina, i_Leak, i, K_erev, Na_C_alpha_h, Na_C_alpha_m, Na_A_alpha_h, Na_gbar, Na_A_alpha_m, K_gbar, K_B_alpha_n, K_e, Leak_erev, comp19_V_t, K_g, K_A_alpha_n, Na_erev, comp20_C, Na_C_beta_h, K_C_beta_n, Na_C_beta_m, Na_A_beta_m, K_B_beta_n, Leak_gbar, Na_B_alpha_m, Na_A_beta_h, Na_e, Na_B_alpha_h, Na_g, Na_B_beta_m, K_C_alpha_n, Leak_g, K_A_beta_n, Leak_e, Na_B_beta_h;

   const Parameters_ *params = &p;

   r_ = 0;

   memset(y_,0,4*sizeof(double));

   K_erev  =  p.K_erev;

   Na_C_alpha_h  =  p.Na_C_alpha_h;

   Na_C_alpha_m  =  p.Na_C_alpha_m;

   Na_A_alpha_h  =  p.Na_A_alpha_h;

   Na_gbar  =  p.Na_gbar;

   Na_A_alpha_m  =  p.Na_A_alpha_m;

   K_gbar  =  p.K_gbar;

   K_B_alpha_n  =  p.K_B_alpha_n;

   K_e  =  p.K_e;

   Leak_erev  =  p.Leak_erev;

   comp19_V_t  =  p.comp19_V_t;

   K_g  =  p.K_g;

   K_A_alpha_n  =  p.K_A_alpha_n;

   Na_erev  =  p.Na_erev;

   comp20_C  =  p.comp20_C;

   Na_C_beta_h  =  p.Na_C_beta_h;

   K_C_beta_n  =  p.K_C_beta_n;

   Na_C_beta_m  =  p.Na_C_beta_m;

   Na_A_beta_m  =  p.Na_A_beta_m;

   comp19_Vrest  =  p.comp19_Vrest;

   K_B_beta_n  =  p.K_B_beta_n;

   Leak_gbar  =  p.Leak_gbar;

   Na_B_alpha_m  =  p.Na_B_alpha_m;

   Na_A_beta_h  =  p.Na_A_beta_h;

   Na_e  =  p.Na_e;

   Na_B_alpha_h  =  p.Na_B_alpha_h;

   Na_g  =  p.Na_g;

   Na_B_beta_m  =  p.Na_B_beta_m;

   K_C_alpha_n  =  p.K_C_alpha_n;

   Leak_g  =  p.Leak_g;

   K_A_beta_n  =  p.K_A_beta_n;

   Leak_e  =  p.Leak_e;

   Na_B_beta_h  =  p.Na_B_beta_h;


   v  =  -65.0;

   Na_h61  =  (Na_ahf(comp19_Vrest, params)) / (Na_ahf(comp19_Vrest, params) + Na_bhf(comp19_Vrest, params));

   Na_h61O  =  Na_h61;

   K_m66  =  (K_anf(comp19_Vrest, params)) / (K_anf(comp19_Vrest, params) + K_bnf(comp19_Vrest, params));

   K_m66O  =  K_m66;

   Na_m60  =  (Na_amf(comp19_Vrest, params)) / (Na_amf(comp19_Vrest, params) + Na_bmf(comp19_Vrest, params));

   Na_m60O  =  Na_m60;

    
   y_[0]  =  v;

   y_[1]  =  Na_h61O;

   y_[2]  =  K_m66O;

   y_[3]  =  Na_m60O;


   if (!((Na_gbar) > (0.0))) 
      { throw BadProperty ("Constraint (> Na:gbar 0.0) is not satisfied."); }; 

   if (!((K_gbar) > (0.0))) 
      { throw BadProperty ("Constraint (> K:gbar 0.0) is not satisfied."); }; 

   if (!((Leak_gbar) > (0.0))) 
      { throw BadProperty ("Constraint (> Leak:gbar 0.0) is not satisfied."); }; 



}


hodgkin_huxley::State_::State_ (const State_& s)  
{

  r_ = s.r_;
        
  for ( int i = 0 ; i < 4 ; ++i ) 
  {
      y_[i] = s.y_[i];
  }

}


hodgkin_huxley::State_& hodgkin_huxley::State_::operator=(const State_& s)
{

  r_ = s.r_;
        
  assert(this != &s);  
  for ( size_t i = 0 ; i < 4 ; ++i )
       y_[i] = s.y_[i];

  return *this;

}


void hodgkin_huxley::Parameters_::get (DictionaryDatum &d) const
{

   def<double_t>(d, "K_erev", K_erev);
   def<double_t>(d, "Na_C_alpha_h", Na_C_alpha_h);
   def<double_t>(d, "Na_C_alpha_m", Na_C_alpha_m);
   def<double_t>(d, "Na_A_alpha_h", Na_A_alpha_h);
   def<double_t>(d, "Na_gbar", Na_gbar);
   def<double_t>(d, "Na_A_alpha_m", Na_A_alpha_m);
   def<double_t>(d, "K_gbar", K_gbar);
   def<double_t>(d, "K_B_alpha_n", K_B_alpha_n);
   def<double_t>(d, "K_e", K_e);
   def<double_t>(d, "Leak_erev", Leak_erev);
   def<double_t>(d, "comp19_V_t", comp19_V_t);
   def<double_t>(d, "K_g", K_g);
   def<double_t>(d, "K_A_alpha_n", K_A_alpha_n);
   def<double_t>(d, "Na_erev", Na_erev);
   def<double_t>(d, "comp20_C", comp20_C);
   def<double_t>(d, "Na_C_beta_h", Na_C_beta_h);
   def<double_t>(d, "K_C_beta_n", K_C_beta_n);
   def<double_t>(d, "Na_C_beta_m", Na_C_beta_m);
   def<double_t>(d, "Na_A_beta_m", Na_A_beta_m);
   def<double_t>(d, "comp19_Vrest", comp19_Vrest);
   def<double_t>(d, "K_B_beta_n", K_B_beta_n);
   def<double_t>(d, "Leak_gbar", Leak_gbar);
   def<double_t>(d, "Na_B_alpha_m", Na_B_alpha_m);
   def<double_t>(d, "Na_A_beta_h", Na_A_beta_h);
   def<double_t>(d, "Na_e", Na_e);
   def<double_t>(d, "Na_B_alpha_h", Na_B_alpha_h);
   def<double_t>(d, "Na_g", Na_g);
   def<double_t>(d, "Na_B_beta_m", Na_B_beta_m);
   def<double_t>(d, "K_C_alpha_n", K_C_alpha_n);
   def<double_t>(d, "Leak_g", Leak_g);
   def<double_t>(d, "K_A_beta_n", K_A_beta_n);
   def<double_t>(d, "Leak_e", Leak_e);
   def<double_t>(d, "Na_B_beta_h", Na_B_beta_h);
    

   def<double_t>(d, "Vrest", Vrest);
   def<double_t>(d, "V_t", V_t);
    
    
}

void hodgkin_huxley::Parameters_::set (const DictionaryDatum &d)
{

   updateValue<double_t>(d, "K_erev", K_erev);

    
   updateValue<double_t>(d, "Na_C_alpha_h", Na_C_alpha_h);

    
   updateValue<double_t>(d, "Na_C_alpha_m", Na_C_alpha_m);

    
   updateValue<double_t>(d, "Na_A_alpha_h", Na_A_alpha_h);

    
   updateValue<double_t>(d, "Na_gbar", Na_gbar);

    
   updateValue<double_t>(d, "Na_A_alpha_m", Na_A_alpha_m);

    
   updateValue<double_t>(d, "K_gbar", K_gbar);

    
   updateValue<double_t>(d, "K_B_alpha_n", K_B_alpha_n);

    
   updateValue<double_t>(d, "K_e", K_e);

    
   updateValue<double_t>(d, "Leak_erev", Leak_erev);

    
   updateValue<double_t>(d, "comp19_V_t", comp19_V_t);

    
   updateValue<double_t>(d, "K_g", K_g);

    
   updateValue<double_t>(d, "K_A_alpha_n", K_A_alpha_n);

    
   updateValue<double_t>(d, "Na_erev", Na_erev);

    
   updateValue<double_t>(d, "comp20_C", comp20_C);

    
   updateValue<double_t>(d, "Na_C_beta_h", Na_C_beta_h);

    
   updateValue<double_t>(d, "K_C_beta_n", K_C_beta_n);

    
   updateValue<double_t>(d, "Na_C_beta_m", Na_C_beta_m);

    
   updateValue<double_t>(d, "Na_A_beta_m", Na_A_beta_m);

    
   updateValue<double_t>(d, "comp19_Vrest", comp19_Vrest);

    
   updateValue<double_t>(d, "K_B_beta_n", K_B_beta_n);

    
   updateValue<double_t>(d, "Leak_gbar", Leak_gbar);

    
   updateValue<double_t>(d, "Na_B_alpha_m", Na_B_alpha_m);

    
   updateValue<double_t>(d, "Na_A_beta_h", Na_A_beta_h);

    
   updateValue<double_t>(d, "Na_e", Na_e);

    
   updateValue<double_t>(d, "Na_B_alpha_h", Na_B_alpha_h);

    
   updateValue<double_t>(d, "Na_g", Na_g);

    
   updateValue<double_t>(d, "Na_B_beta_m", Na_B_beta_m);

    
   updateValue<double_t>(d, "K_C_alpha_n", K_C_alpha_n);

    
   updateValue<double_t>(d, "Leak_g", Leak_g);

    
   updateValue<double_t>(d, "K_A_beta_n", K_A_beta_n);

    
   updateValue<double_t>(d, "Leak_e", Leak_e);

    
   updateValue<double_t>(d, "Na_B_beta_h", Na_B_beta_h);

    
    


   updateValue<double_t>(d, "Vrest", Vrest);

    
   updateValue<double_t>(d, "V_t", V_t);

    
    


   Vrest  =  comp19_Vrest;

   V_t  =  comp19_V_t;

    

}


void hodgkin_huxley::State_::get (DictionaryDatum &d) const
{

   def<double_t>(d, "Na_m60O", y_[]);

   def<double_t>(d, "K_m66O", y_[]);

   def<double_t>(d, "Na_h61O", y_[]);

   def<double_t>(d, "v", y_[]);

    
    
   def<double_t>(d, names::V_m, y_[]);

    
    
}
    
void hodgkin_huxley::State_::set (const DictionaryDatum &d, const Parameters_&)
{

   updateValue<double_t>(d, "Na_m60O", y_[]);

   updateValue<double_t>(d, "K_m66O", y_[]);

   updateValue<double_t>(d, "Na_h61O", y_[]);

   updateValue<double_t>(d, "v", y_[]);

    

   updateValue<double_t>(d, names::V_m, y_[]);

    
    
}



hodgkin_huxley::Buffers_::Buffers_(hodgkin_huxley& n)
    : logger_(n),
      s_(0),
      c_(0),
      e_(0),
      N(0),
      u(0),
      jac(0)
{
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}


hodgkin_huxley::Buffers_::Buffers_(const Buffers_&, hodgkin_huxley& n)
    : logger_(n),
      s_(0),
      c_(0),
      e_(0),
      N(0),
      u(0),
      jac(0)
{
    // Initialization of the remaining members is deferred to
    // init_buffers_().
}




RecordablesMap<hodgkin_huxley> hodgkin_huxley::recordablesMap_;

template <> void RecordablesMap<hodgkin_huxley>::create()
{

   insert_("Na_m60O", &hodgkin_huxley::get_y_elem_<hodgkin_huxley::State_::NA_M60O>);

   insert_("K_m66O", &hodgkin_huxley::get_y_elem_<hodgkin_huxley::State_::K_M66O>);

   insert_("Na_h61O", &hodgkin_huxley::get_y_elem_<hodgkin_huxley::State_::NA_H61O>);

   insert_("v", &hodgkin_huxley::get_y_elem_<hodgkin_huxley::State_::V>);


   insert_(names::V_m, &hodgkin_huxley::get_y_elem_<hodgkin_huxley::State_::V>);


}


hodgkin_huxley::hodgkin_huxley()
    : Archiving_Node(), 
      P_(), 
      S_(P_),
      B_(*this)
{
    recordablesMap_.create();
}


hodgkin_huxley::hodgkin_huxley(const hodgkin_huxley& n)
    : Archiving_Node(n), 
      P_(n.P_), 
      S_(n.S_),
      B_(n.B_, *this)
{
}


hodgkin_huxley::~hodgkin_huxley ()
{
    // GSL structs only allocated by init_nodes_(), so we need to protect destruction
    if ( B_.s_ != NULL) gsl_odeiv2_step_free (B_.s_);
    if ( B_.c_ != NULL) gsl_odeiv2_control_free (B_.c_);
    if ( B_.e_ != NULL) gsl_odeiv2_evolve_free (B_.e_);
    if ( B_.u != NULL) free (B_.u);
    if ( B_.jac != NULL) free (B_.jac);
}


void hodgkin_huxley::init_node_(const Node& proto)
{
    const hodgkin_huxley& pr = downcast<hodgkin_huxley>(proto);
    P_ = pr.P_;
    S_ = State_(P_);
}


void hodgkin_huxley::init_state_(const Node& proto)
{
    const hodgkin_huxley& pr = downcast<hodgkin_huxley>(proto);
    S_ = State_(pr.P_);
}


void hodgkin_huxley::init_buffers_()
{
   
   B_.currents_.clear();           
   Archiving_Node::clear_history();

   B_.logger_.reset();

   B_.step_ = Time::get_resolution().get_ms();
   B_.IntegrationStep_ = B_.step_;

   B_.I_stim_ = 0.0;


   static const gsl_odeiv2_step_type* T1 = gsl_odeiv2_step_rk2;
   B_.N = 4;
  
   if ( B_.s_ == 0 )
     B_.s_ = gsl_odeiv2_step_alloc (T1, B_.N);
   else 
     gsl_odeiv2_step_reset(B_.s_);
    
   if ( B_.c_ == 0 )  
     B_.c_ = gsl_odeiv2_control_standard_new (1e-7, 
                                              1e-7, 1.0, 0.0);
   else
     gsl_odeiv2_control_init(B_.c_, 1e-7, 
                             1e-7, 1.0, 0.0);
    
   if ( B_.e_ == 0 )  
     B_.e_ = gsl_odeiv2_evolve_alloc(B_.N);
   else 
     gsl_odeiv2_evolve_reset(B_.e_);
   
   B_.sys_.function  = hodgkin_huxley_dynamics; 
   B_.sys_.jacobian  = hodgkin_huxley_jacobian;
   B_.sys_.dimension = B_.N;
   B_.sys_.params    = reinterpret_cast<void*>(this);

   B_.u = (double *)malloc(sizeof(double) * B_.N);
   assert (B_.u);
   B_.jac = (double *)malloc(sizeof(double) * B_.N);
   assert (B_.jac);

}


void hodgkin_huxley::calibrate()
{
    B_.logger_.init();  
    V_.U_old_ = S_.y_[];    V_.RefractoryCounts_ = 0;
}






    
  void hodgkin_huxley::update(Time const & origin, const long_t from, const long_t to)
  {

    assert(to >= 0 && (delay) from < Scheduler::get_min_delay());
    assert(from < to);

    double tout;
    long_t current_steps = origin.get_steps();

    for ( long_t lag = from ; lag < to ; ++lag )
      {
        double h = B_.step_;    
	double tt = 0.0 ; 


        V_.U_old_ = S_.y_[];

        while (tt < h)
        {

           const int status = 
             gsl_odeiv2_evolve_apply
             (B_.e_, B_.c_, B_.s_, 
              &B_.sys_, // system of ODE
              &tt, // from t...
              h, // ...to t=t+h
              &B_.IntegrationStep_, // integration window (written on!)
              S_.y_); // neuron state

           if ( status != GSL_SUCCESS )
             throw GSLSolverFailure(get_name(), status);

        }
        
        

         if ( S_.r_ > 0 )
	    S_.r_--;
         else
	    if (S_.y_[] >= P_.V_t && V_.U_old_ > S_.y_[])
	      {
                S_.r_ = V_.RefractoryCounts_;
		set_spiketime(Time::step(origin.get_steps()+lag+1));
		SpikeEvent se;
		network()->send(*this, se, lag);
	      };


        
  int events = 0;



  /* Resets the GSL stepping function if any synaptic events have occurred */
  if (events > 0)
  {
     gsl_odeiv2_step_reset (B_.s_);
  }


        B_.I_stim_ = B_.currents_.get_value(lag);
        B_.logger_.record_data(current_steps + lag);
      }
  }

  
void hodgkin_huxley::handle(SpikeEvent & e)
  {
    int flag;
    assert(e.get_delay() > 0);
    flag = 0;


  }


void hodgkin_huxley::handle(CurrentEvent& e)
  {
    assert(e.get_delay() > 0);

    const double_t c = e.get_current();
    const double_t w = e.get_weight();

    B_.currents_.add_value(e.get_rel_delivery_steps(network()->get_slice_origin()), w * c);
  }


void hodgkin_huxley::handle(DataLoggingRequest& e)
  {
    B_.logger_.handle(e);
  }}